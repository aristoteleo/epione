

from anndata import AnnData
import snapatac2._snapatac2 as internal
import numpy as np
import snapatac2
import matplotlib.pyplot as plt
import seaborn as sns
from ..utils import console
from typing import Union, Optional


def is_anndata(data) -> bool:
    return isinstance(data, AnnData) or isinstance(data, internal.AnnData) or isinstance(data, internal.AnnDataSet)


def frag_size_distr(
    adata: AnnData | np.ndarray,
    use_rep: str = "frag_size_distr",
    max_recorded_size: int = 1000,
    figsize: tuple = (4, 4), 
    ax: plt.Axes = None,
    title: str = "Fragment size distribution",
    xlabel: str = "Fragment size",
    ylabel: str = "Count",
    log_y: bool = False,
    **kwargs,
) -> tuple[plt.Figure, plt.Axes] | None:
    """ Plot the fragment size distribution.
    """
    from ..pp import frag_size_distr as pp_frag_size_distr
    if is_anndata(adata):
        if use_rep not in adata.uns or len(adata.uns[use_rep]) <= max_recorded_size:
            console.level2("Computing fragment size distribution...")
            pp_frag_size_distr(adata, add_key=use_rep, max_recorded_size=max_recorded_size)
        data = adata.uns[use_rep]
    else:
        data = adata
    data = data[:max_recorded_size+1]

    x, y = zip(*enumerate(data))
    # Make a line plot
    if ax==None:
        fig, ax = plt.subplots(figsize=figsize)
    ax.plot(x, y, **kwargs)
    ax.set_title(title)
    ax.set_xlabel(xlabel)
    ax.set_ylabel(ylabel)
    if log_y:
        ax.set_yscale('log')
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    ax.spines['bottom'].set_visible(True)
    ax.spines['left'].set_visible(True)
    ax.grid(False)
    return fig, ax

def tss_enrichment(
    data,
    color= None,
    title: str = "TSS Enrichment",
    ax= None,
):
    """
    Plot relative enrichment scores around a TSS.

    Parameters
    ----------
    data
        AnnData object with cell x TSS_position matrix as generated by `muon.atac.tl.tss_enrichment`.
    color
        Column name of .obs slot of the AnnData object which to group TSS signals by.
    title
        Plot title.
    ax
        A matplotlib axes object.
    """
    ax = ax or plt.gca()

    if color is not None:
        if isinstance(color, str):
            color = [color]

        groups = data.obs.groupby(color)

        for name, group in groups:
            ad = data[group.index]
            _tss_enrichment_single(ad, ax, label=name)
    else:
        _tss_enrichment_single(data, ax)

    # TODO Not sure how to best deal with plot returning/showing
    ax.set_title(title)
    ax.set_xlabel("Distance from TSS, bp")
    ax.set_ylabel("Average TSS enrichment score")
    if color:
        ax.legend(loc="upper right", title=", ".join(color))
    return ax


def _tss_enrichment_single(data, ax, sd: bool = False, *args, **kwargs):
    x = data.var["TSS_position"]
    means = data.X.mean(axis=0)
    ax.plot(x, means, **kwargs)
    if sd:
        sd = np.sqrt(data.X.var(axis=0))
        plt.fill_between(
            x,
            means - sd,
            means + sd,
            alpha=0.2,
        )


def fragment_histogram(
    data: Union[AnnData],
    region: str = "chr1-1-2000000",
    groupby: Optional[Union[str]] = None,
    barcodes: Optional[str] = None,
    show: Optional[bool] = None,
    save: Union[str, bool, None] = None,
):
    """
    Plot Histogram of Fragment lengths within specified region.
    Parameters
    ----------
    data
        AnnData object with peak counts or multimodal MuData object with 'atac' modality.
    region
        Region to plot. Specified with the format `chr1:1-2000000` or`chr1-1-2000000`.
    groupby
        Column name(s) of .obs slot of the AnnData object according to which the plot is split.
    barcodes
        Column name of .obs slot of the AnnData object
        with barcodes corresponding to the ones in the fragments file.
    show
        Show the plot, do not return axis.
    save
        If `True` or a `str`, save the figure.
        A string is appended to the default filename.
        Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.
    """
    from scanpy.plotting._utils import savefig_or_show
    from ..utils._read import fetch_regions_to_df

    if isinstance(data, AnnData):
        adata = data
    else:
        raise TypeError("Expected AnnData or MuData object with 'atac' modality")

    fragment_path = adata.uns["files"]["fragments"]
    fragments = fetch_regions_to_df(fragment_path=fragment_path, features=region)

    fragments["length"] = fragments.End - fragments.Start
    fragments.set_index(keys="Cell", inplace=True)
    if barcodes and barcodes in adata.obs.columns:
        fragments = fragments.join(adata.obs.set_index(barcodes), how="right")
    else:
        fragments = fragments.join(adata.obs, how="right")

    # Handle sns.distplot deprecation and sns.histplot addition
    hist = sns.histplot if hasattr(sns, "histplot") else sns.distplot

    binwidth = 5
    if hasattr(sns, "histplot"):
        kwargs = {"binwidth": binwidth}
    else:
        n_bins = int(np.ceil(fragments.length.max() / binwidth))
        kwargs = {"bins": n_bins, "kde": False}

    if groupby is not None:
        if isinstance(groupby, str):
            groupby = [groupby]
        if len(groupby) > 2:
            raise ValueError("Maximum 2 categories in groupby")
        elif len(groupby) == 2:
            g = sns.FacetGrid(fragments, col=groupby[0], row=groupby[1], sharey=False)
        elif len(groupby) == 1:
            g = sns.FacetGrid(fragments, col=groupby[0], sharey=False)
        g.map(hist, "length", **kwargs)
        g.set_xlabels("Fragment length (bp)")
    else:
        # Handle sns.distplot deprecation and sns.histplot addition
        g = hist(fragments.length, **kwargs)
        g.set_xlabel("Fragment length (bp)")
    g.set(xlim=(0, 1000))
    return g